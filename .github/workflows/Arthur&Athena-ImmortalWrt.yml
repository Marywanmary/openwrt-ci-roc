name: Arthur&Athena-ImmWrt

on:
  # æ‰‹åŠ¨è§¦å‘
  workflow_dispatch:
  # å®šæ—¶è§¦å‘ï¼šåŒ—äº¬æ—¶é—´å‘¨äº”0ç‚¹ = UTCå‘¨å››16ç‚¹
  schedule:
    - cron: '0 16 * * 4'
  # æ¸…ç†åè§¦å‘
  workflow_run:
    workflows: ["All-Clean"]
    types:
      - completed

env:
  REPO_URL: https://github.com/laipeng668/immortalwrt.git
  REPO_BRANCH: master
  CONFIG_FILE: configs/Arthur&Athena.config
  GENERAL_CONFIG_FILE: configs/General.config
  DIY_SCRIPT: scripts/Roc-script.sh
  CLASH_KERNEL: amd64
  MADS: true
  UPLOAD_BIN_DIR: false
  FIRMWARE_RELEASE: true
  FIRMWARE_TAG: Arthur&Athena
  TZ: Asia/Shanghai

jobs:
  Build:
    runs-on: ubuntu-22.04

    steps:
    - name: Check Server Performance(æ£€æŸ¥æœåŠ¡å™¨æ€§èƒ½)
      # Enable strict error handling mode, any command failure will terminate immediately
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼ï¼Œä»»ä½•å‘½ä»¤å¤±è´¥éƒ½ä¼šç«‹å³ç»ˆæ­¢
      run: |
        set -euo pipefail
        
        echo "è­¦å‘Šâš "
        echo "åˆ†é…çš„æœåŠ¡å™¨æ€§èƒ½æœ‰é™ï¼Œè‹¥é€‰æ‹©çš„æ’ä»¶è¿‡å¤šï¼ŒåŠ¡å¿…æ³¨æ„CPUæ€§èƒ½ï¼"
        echo -e "å·²çŸ¥CPUå‹å·ï¼ˆé™åºï¼‰ï¼š7763ï¼Œ8370Cï¼Œ8272CLï¼Œ8171Mï¼ŒE5-2673 \n"
        echo "--------------------------CPUä¿¡æ¯--------------------------"
        
        # Use more reliable commands to get CPU information
        # ä½¿ç”¨æ›´å¯é çš„å‘½ä»¤è·å–CPUä¿¡æ¯
        if command -v lscpu >/dev/null 2>&1; then
          echo "CPUç‰©ç†æ•°é‡ï¼š$(lscpu | grep 'Socket(s):' | awk '{print $2}')"
          echo -e "CPUæ ¸å¿ƒä¿¡æ¯ï¼š$(lscpu | grep 'Model name:' | cut -d: -f2 | xargs)"
        else
          echo "CPUç‰©ç†æ•°é‡ï¼š$(cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l)"
          echo -e "CPUæ ¸å¿ƒä¿¡æ¯ï¼š$(cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c)"
        fi
        
        echo "--------------------------å†…å­˜ä¿¡æ¯--------------------------"
        echo "å·²å®‰è£…å†…å­˜è¯¦ç»†ä¿¡æ¯ï¼š"
        # Check if lshw command exists
        # æ£€æŸ¥lshwå‘½ä»¤æ˜¯å¦å­˜åœ¨
        if command -v lshw >/dev/null 2>&1; then
          echo -e "$(sudo lshw -short -C memory | grep GiB) \n"
        else
          echo "å†…å­˜ä¿¡æ¯è·å–å¤±è´¥ \n"
        fi
        
        #echo "--------------------------ç¡¬ç›˜ä¿¡æ¯--------------------------"
        ## Safely get disk count
        ## å®‰å…¨åœ°è·å–ç¡¬ç›˜æ•°é‡
        #DISK_COUNT=$(ls /dev/sd* 2>/dev/null | grep -v [1-9] | wc -l)
        #echo "ç¡¬ç›˜æ•°é‡ï¼š$DISK_COUNT" && df -hT

    - name: Maximize Available Disk Space(æœ€å¤§åŒ–å¯ç”¨ç£ç›˜ç©ºé—´â€‹)
      if: env.MADS == 'true'
      uses: AdityaGarg8/remove-unwanted-software@master
      with:
        remove-dotnet: "true"
        remove-android: "true"
        remove-haskell: "true"
        remove-codeql: "true"
        remove-docker-images: "true"
        remove-large-packages: "true"
        remove-cached-tools: "true"
        remove-swapfile: "true"


    - name: Initialization Environment(åˆå§‹åŒ–ç¯å¢ƒ)
      env:
        DEBIAN_FRONTEND: noninteractive
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        
        # Update package manager and install dependencies
        # æ›´æ–°åŒ…ç®¡ç†å™¨å¹¶å®‰è£…ä¾èµ–
        sudo -E apt-get -y update || { echo "APT update failed"; exit 1; }
        sudo -E apt-get -y install $(curl -fsSL is.gd/depends_ubuntu_2204) || { echo "Package installation failed"; exit 1; }
        sudo -E systemctl daemon-reload || { echo "Systemctl daemon reload failed"; exit 1; }
        sudo -E apt-get -y autoremove --purge || { echo "Autoremove failed"; exit 1; }
        sudo -E apt-get -y clean || { echo "APT clean failed"; exit 1; }
        sudo timedatectl set-timezone "$TZ" || { echo "Timezone setting failed"; exit 1; }

    - name: Checkout(æ£€å‡ºä»£ç )
      uses: actions/checkout@main

    - name: Clone Source Code(å…‹éš†æºä»£ç )
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        
        # Check workspace disk space
        # æ£€æŸ¥å·¥ä½œç©ºé—´ç£ç›˜ç©ºé—´
        df -hT $GITHUB_WORKSPACE || { echo "Disk space check failed"; exit 1; }
        
        # Create and set OpenWrt directory permissions
        # åˆ›å»ºå¹¶è®¾ç½®OpenWrtç›®å½•æƒé™
        sudo mkdir -p /mnt/openwrt || { echo "Failed to create directory"; exit 1; }
        sudo chown -R $(id -u):$(id -g) /mnt/openwrt || { echo "Failed to set ownership"; exit 1; }
        
        # Clone source code repository
        # å…‹éš†æºä»£ç ä»“åº“
        git clone --depth 1 -b $REPO_BRANCH --single-branch $REPO_URL /mnt/openwrt || { echo "Git clone failed"; exit 1; }
        cd /mnt/openwrt || { echo "Failed to change directory"; exit 1; }
        
        # Verify Git repository was successfully cloned
        # éªŒè¯Gitä»“åº“æ˜¯å¦æˆåŠŸå…‹éš†
        if [ ! -d .git ]; then
          echo "Git repository not found after clone"
          exit 1
        fi
        
        # Set environment variables
        # è®¾ç½®ç¯å¢ƒå˜é‡
        echo "OPENWRT_PATH=$PWD" >> $GITHUB_ENV
        VERSION_INFO=$(git show -s --date=short --format="ä½œè€…: %an<br/>æ—¶é—´: %cd<br/>å†…å®¹: %s<br/>hash: %H")
        echo "VERSION_INFO=$VERSION_INFO" >> $GITHUB_ENV
        
        # Get kernel version information
        # è·å–å†…æ ¸ç‰ˆæœ¬ä¿¡æ¯
        if [ -f target/linux/generic/kernel-6.12 ]; then
          VERSION_KERNEL=$(grep -oP 'LINUX_KERNEL_HASH-\K[0-9]+\.[0-9]+\.[0-9]+' target/linux/generic/kernel-6.12)
          echo "VERSION_KERNEL=$VERSION_KERNEL" >> $GITHUB_ENV
        else
          echo "Kernel version file not found"
        fi

    - name: Generate Variables(ç”Ÿæˆå˜é‡)
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        
        # Check if configuration files exist
        # æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if [ ! -f "$CONFIG_FILE" ]; then
          echo "Configuration file not found: $CONFIG_FILE"
          exit 1
        fi
        
        # Copy configuration file and generate default config
        # å¤åˆ¶é…ç½®æ–‡ä»¶å¹¶ç”Ÿæˆé»˜è®¤é…ç½®
        cp "$CONFIG_FILE" "$OPENWRT_PATH/.config" || { echo "Config copy failed"; exit 1; }
        cd "$OPENWRT_PATH" || { echo "Failed to change directory"; exit 1; }
        make defconfig > /dev/null 2>&1 || { echo "Defconfig generation failed"; exit 1; }
        
        # Extract source repository name
        # æå–æºç ä»“åº“åç§°
        SOURCE_REPO="$(echo "$REPO_URL" | awk -F '/' '{print $(NF)}')"
        echo "SOURCE_REPO=${SOURCE_REPO}" >> $GITHUB_ENV
        
        # Extract device target platform information
        # æå–è®¾å¤‡ç›®æ ‡å¹³å°ä¿¡æ¯
        DEVICE_TARGET=$(grep CONFIG_TARGET_BOARD .config | awk -F '"' '{print $2}')
        echo "DEVICE_TARGET=${DEVICE_TARGET}" >> $GITHUB_ENV
        
        DEVICE_SUBTARGET=$(grep CONFIG_TARGET_SUBTARGET .config | awk -F '"' '{print $2}')
        echo "DEVICE_SUBTARGET=${DEVICE_SUBTARGET}" >> $GITHUB_ENV
        
        # Get Git commit hash and cache timestamp
        # è·å–Gitæäº¤å“ˆå¸Œå’Œç¼“å­˜æ—¶é—´æˆ³
        echo "HASH=$(git log -1 --pretty=format:'%h')" >> $GITHUB_ENV
        echo "CACHE_DATE=$(date +"%Y-%m-%d %H:%M:%S")" >> $GITHUB_ENV

    - name: Cache Toolchain(ç¼“å­˜å·¥å…·é“¾)
      uses: actions/cache@main
      with:
        key: ${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.DEVICE_TARGET }}-${{ env.DEVICE_SUBTARGET }}-${{ env.HASH }} ${{ env.CACHE_DATE }}
        restore-keys: ${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.DEVICE_TARGET }}-${{ env.DEVICE_SUBTARGET }}-
        path: |
          ${{ env.OPENWRT_PATH }}/.ccache
          ${{ env.OPENWRT_PATH }}/staging_dir

    - name: Refresh The Cache(åˆ·æ–°ç¼“å­˜)
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        
        # If staging_dir directory exists, refresh timestamps
        # å¦‚æœå­˜åœ¨staging_dirç›®å½•ï¼Œåˆ™åˆ·æ–°æ—¶é—´æˆ³
        if [ -d "$OPENWRT_PATH/staging_dir" ]; then
          find "$OPENWRT_PATH/staging_dir" -type d -name "stamp" -not -path "*target*" | while read -r dir; do
              find "$dir" -type f -exec touch {} + || echo "Warning: Failed to touch files in $dir"
          done
        fi

    - name: Install Feeds(å®‰è£…feeds)
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        
        # Change to OpenWrt directory and update feeds
        # åˆ‡æ¢åˆ°OpenWrtç›®å½•å¹¶æ›´æ–°feeds
        cd "$OPENWRT_PATH" || { echo "Failed to change directory"; exit 1; }
        ./scripts/feeds update -a || { echo "Feeds update failed"; exit 1; }
        ./scripts/feeds install -a || { echo "Feeds install failed"; exit 1; }

    - name: Load Custom Configuration(åŠ è½½è‡ªå®šä¹‰é…ç½®)
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        
        # Check if configuration files exist
        # æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if [ ! -f "$CONFIG_FILE" ] || [ ! -f "$GENERAL_CONFIG_FILE" ]; then
          echo "Required config files missing"
          exit 1
        fi
        
        # Merge configuration files
        # åˆå¹¶é…ç½®æ–‡ä»¶
        awk '!seen[$0]++' $CONFIG_FILE $GENERAL_CONFIG_FILE > $OPENWRT_PATH/.config || { echo "Config merge failed"; exit 1; }
        
        # Set custom script permissions and execute
        # è®¾ç½®è‡ªå®šä¹‰è„šæœ¬æƒé™å¹¶æ‰§è¡Œ
        chmod +x "$DIY_SCRIPT" || { echo "Failed to set script permissions"; exit 1; }
        cd "$OPENWRT_PATH" || { echo "Failed to change directory"; exit 1; }
        "$GITHUB_WORKSPACE/$DIY_SCRIPT" || { echo "Custom DIY script failed"; exit 1; }

    - name: Download DL Package(ä¸‹è½½DLè½¯ä»¶åŒ…)
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        
        # Change directory and generate default configuration
        # åˆ‡æ¢ç›®å½•å¹¶ç”Ÿæˆé»˜è®¤é…ç½®
        cd "$OPENWRT_PATH" || { echo "Failed to change directory"; exit 1; }
        make defconfig || { echo "Defconfig failed"; exit 1; }
        
        # Download dependencies
        # ä¸‹è½½ä¾èµ–åŒ…
        make download -j$(nproc) || { echo "Package download failed"; exit 1; }
        
        # Clean up files smaller than 1KB (possibly failed downloads)
        # æ¸…ç†å°äº1KBçš„æ–‡ä»¶ï¼ˆå¯èƒ½æ˜¯ä¸‹è½½å¤±è´¥çš„æ–‡ä»¶ï¼‰
        find dl -size -1024c -exec ls -l {} \;
        find dl -size -1024c -exec rm -f {} \;

    - name: Compile Firmware(å¼€å§‹ç¼–è¯‘å›ºä»¶)
      id: compile
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        
        # Change to OpenWrt directory
        # åˆ‡æ¢åˆ°OpenWrtç›®å½•
        cd "$OPENWRT_PATH" || { echo "Failed to change directory"; exit 1; }
        
        # Check if sufficient disk space is available
        # æ£€æŸ¥ç£ç›˜ç©ºé—´æ˜¯å¦å……è¶³
        FREE_SPACE=$(df -m . | tail -1 | awk '{print $4}')
        if [ "$FREE_SPACE" -lt 2000 ]; then
          echo "è­¦å‘Šï¼šå¯ç”¨ç©ºé—´ä¸è¶³2GBï¼Œå¯èƒ½å½±å“ç¼–è¯‘"
        fi
        
        echo -e "$(nproc) thread compile"
        
        # Multi-threaded compilation, if it fails try single-threaded compilation, then detailed mode compilation
        # å¤šçº¿ç¨‹ç¼–è¯‘ï¼Œå¦‚æœå¤±è´¥åˆ™å°è¯•å•çº¿ç¨‹ç¼–è¯‘ï¼Œå†å¤±è´¥åˆ™è¯¦ç»†æ¨¡å¼ç¼–è¯‘
        if ! make -j$(nproc); then
          echo "ç¬¬ä¸€è½®ç¼–è¯‘å¤±è´¥ï¼Œå°è¯•å•çº¿ç¨‹ç¼–è¯‘"
          if ! make -j1; then
            echo "å•çº¿ç¨‹ç¼–è¯‘ä¹Ÿå¤±è´¥ï¼Œå°è¯•è¯¦ç»†æ¨¡å¼ç¼–è¯‘"
            if ! make -j1 V=s; then
              echo "æ‰€æœ‰ç¼–è¯‘æ–¹å¼éƒ½å¤±è´¥"
              exit 1
            fi
          fi
        fi
        
        # Set compilation success flag and timestamp
        # è®¾ç½®ç¼–è¯‘æˆåŠŸæ ‡å¿—å’Œæ—¶é—´æˆ³
        echo "status=success" >> $GITHUB_OUTPUT
        echo "DATE=$(date +"%Y-%m-%d %H:%M:%S")" >> $GITHUB_ENV
        echo "FILE_DATE=$(date +"%Y.%m.%d")" >> $GITHUB_ENV

    - name: Check Space Usage(æ£€æŸ¥ç©ºé—´ä½¿ç”¨æƒ…å†µ)
      if: (!cancelled())
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        df -hT

    - name: Upload Bin Directory(ä¸Šä¼ å›ºä»¶)
      if: steps.compile.outputs.status == 'success' && env.UPLOAD_BIN_DIR == 'true'
      uses: actions/upload-artifact@main
      with:
        name: ${{ env.SOURCE_REPO }}-bin-${{ env.DEVICE_TARGET }}-${{ env.DEVICE_SUBTARGET }}-${{ env.FILE_DATE }}
        path: ${{ env.OPENWRT_PATH }}/bin

    - name: Organize Files(æ•´ç†æ–‡ä»¶)
      if: steps.compile.outputs.status == 'success'
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        
        # Change to firmware output directory safely
        # å®‰å…¨åœ°åˆ‡æ¢åˆ°å›ºä»¶è¾“å‡ºç›®å½•
        cd "$OPENWRT_PATH/bin/targets" || { echo "Failed to change to targets directory"; exit 1; }
        
        # Find actual firmware directory using safe method
        # ä½¿ç”¨å®‰å…¨æ–¹æ³•æŸ¥æ‰¾å®é™…çš„å›ºä»¶ç›®å½•
        TARGET_DIR=""
        for dir in */*; do
          if [ -d "$dir" ] && [ -f "$dir/config.buildinfo" ]; then
            TARGET_DIR="$dir"
            break
          fi
        done
        
        if [ -z "$TARGET_DIR" ]; then
          echo "No valid firmware directory found"
          exit 1
        fi
        
        cd "$TARGET_DIR" || { echo "Failed to change to firmware directory"; exit 1; }
        
        # Check if config file exists
        # æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if [ ! -f "$OPENWRT_PATH/.config" ]; then
          echo "Config file missing in build directory"
          exit 1
        fi
        
        # Copy and rename configuration file
        # å¤åˆ¶å’Œé‡å‘½åé…ç½®æ–‡ä»¶
        cp "$OPENWRT_PATH/.config" Arthur.Athena.config || { echo "Config copy failed"; exit 1; }
        mv config.buildinfo Arthur.Athena.config.buildinfo || { echo "Buildinfo rename failed"; exit 1; }
        
        # Safely rename manifest file
        # å®‰å…¨åœ°é‡å‘½åmanifestæ–‡ä»¶
        if [ -f "openwrt-qualcommax-ipq60xx.manifest" ]; then
          mv openwrt-qualcommax-ipq60xx.manifest openwrt-qualcommax-ipq60xx-Arthur.Athena.manifest || { echo "Manifest rename failed"; exit 1; }
        fi
        
        # Create packages directory and move APK files
        # åˆ›å»ºpackagesç›®å½•å¹¶ç§»åŠ¨APKæ–‡ä»¶
        mkdir -p packages || { echo "Failed to create packages directory"; exit 1; }
        if [ -d "$OPENWRT_PATH/bin/packages" ]; then
          find "$OPENWRT_PATH/bin/packages" -name "*.apk" -exec mv {} packages/ \; 2>/dev/null || true
        fi
        
        # Create compressed package and clean temporary files
        # åˆ›å»ºå‹ç¼©åŒ…å¹¶æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        tar -zcf Arthur.Athena.Packages.tar.gz packages || { echo "Package archive creation failed"; exit 1; }
        rm -rf packages feeds.buildinfo version.buildinfo sha256sums profiles.json || { echo "Cleanup failed"; exit 1; }
        
        # Set firmware path environment variable
        # è®¾ç½®å›ºä»¶è·¯å¾„ç¯å¢ƒå˜é‡
        echo "FIRMWARE_PATH=$PWD" >> $GITHUB_ENV

    - name: Upload Firmware To Artifact(å°†å›ºä»¶ä¸Šä¼ åˆ°Artifact)
      if: steps.compile.outputs.status == 'success' && env.FIRMWARE_RELEASE != 'true'
      uses: actions/upload-artifact@main
      with:
        name: ${{ env.SOURCE_REPO }}-firmware-${{ env.DEVICE_TARGET }}-${{ env.DEVICE_SUBTARGET }}-${{ env.FILE_DATE }}
        path: ${{ env.FIRMWARE_PATH }}

    - name: Upload Firmware To Release(å‘å¸ƒå›ºä»¶)
      if: steps.compile.outputs.status == 'success' && env.FIRMWARE_RELEASE == 'true'
      uses: ncipollo/release-action@main
      with:
        name: ${{ env.DATE }} for ${{ env.FIRMWARE_TAG }}
        allowUpdates: true
        tag: ${{ env.FIRMWARE_TAG }}
        token: ${{ secrets.GITHUB_TOKEN }}
        artifacts: ${{ env.FIRMWARE_PATH }}/*
        body: |
          **This is OpenWrt Firmware for ${{ env.FIRMWARE_TAG }}**
          ### ğŸ“’ å›ºä»¶ä¿¡æ¯
          - è¿™æ˜¯å¼€å¯å…¨åŠŸèƒ½NSSçš„6.12å†…æ ¸å›ºä»¶ï¼Œé»˜è®¤ä¸»é¢˜ä¸ºArgonï¼›è¯¥å›ºä»¶åœ¨ImmortalWrtçš„åŸºç¡€ä¸Šï¼Œæ·»åŠ äº†é¢å¤–çš„è½¯ä»¶åŒ…ï¼Œå…·ä½“è¯¦è§å¯¹åº”æœºå‹çš„configã€‚
          - ğŸ’» è¿™æ˜¯ ${{ env.FIRMWARE_TAG }} å¹³å°ä½¿ç”¨çš„ OpenWrt å›ºä»¶
          - âš½ å›ºä»¶æºç : ${{ env.REPO_URL }}
          - ğŸ’ æºç åˆ†æ”¯: ${{ env.REPO_BRANCH }}
          - ğŸŒ é»˜è®¤åœ°å€: **192.168.111.1**
          - ğŸ”‘ é»˜è®¤å¯†ç : none
          - ğŸš€ WiFiåç§°: **Star**
          - ğŸ”‘ WiFiå¯†ç : 12345678
          ### ğŸ§Š å›ºä»¶ç‰ˆæœ¬
          - å›ºä»¶å†…æ ¸ç‰ˆæœ¬ï¼š**${{ env.VERSION_KERNEL }}**
          - å›ºä»¶ç¼–è¯‘å‰æœ€åä¸€æ¬¡â¦[ä¸»æºç ](${{ env.REPO_URL }})æ›´æ–°è®°å½•
          - ${{ env.VERSION_INFO }}

    - name: Delete Old Cache(åˆ é™¤æ—§ç¼“å­˜)
      # Enable strict error handling mode
      # å¯ç”¨ä¸¥æ ¼é”™è¯¯å¤„ç†æ¨¡å¼
      run: |
        set -euo pipefail
        
        # Check if GitHub CLI is available
        # æ£€æŸ¥GitHub CLIæ˜¯å¦å¯ç”¨
        if ! command -v gh >/dev/null 2>&1; then
          echo "GitHub CLI not available, skipping cache cleanup"
          exit 0
        fi
        
        # Get and delete old caches
        # è·å–å¹¶åˆ é™¤æ—§ç¼“å­˜
        echo "æ­£åœ¨æ¸…ç†ç¼“å­˜..."
        gh cache list --key "${{ env.SOURCE_REPO }}-${{ env.REPO_BRANCH }}-${{ env.DEVICE_TARGET }}-${{ env.DEVICE_SUBTARGET }}-" --json key --jq '.[] | .key' 2>/dev/null | while read -r key; do
          if [ -n "$key" ]; then
            echo "åˆ é™¤ç¼“å­˜: $key"
            gh cache delete "$key" 2>/dev/null || echo "ç¼“å­˜åˆ é™¤å¤±è´¥: $key"
          fi
        done
        
        # Output cache status information
        # è¾“å‡ºç¼“å­˜çŠ¶æ€ä¿¡æ¯
        echo "========cache status========"
        if [ -d "$OPENWRT_PATH/.ccache" ]; then
          echo "ccache: $(du -sh "$OPENWRT_PATH/.ccache" | cut -f 1)"
        else
          echo "ccache: æ— "
        fi
        
        if [ -d "$OPENWRT_PATH/staging_dir" ]; then
          echo "staging: $(du -sh "$OPENWRT_PATH/staging_dir" | cut -f 1)"
        else
          echo "staging: æ— "
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
